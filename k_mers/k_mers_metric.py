# This script computes metric based in k-mer
# You can either choose to compute the metrics for scaffolds or species
# The script will compute the metrics for all the scaffolds or species

# To make it work you need to use the k_mers_to_metric function specifying:
# - level: 'scaffold' or 'species'
# - origin: the scaffold or species of interest
# - df_k_mers: the dataframe containing the k-mers information
# - df_length: the dataframe containing the length information
# - k_mers_counter: the dataframe containing the number of k-mers information

# For computing the similarity metric between two scaffolds or species, we need:
# - The probability of finding a common k-mer: common k-mers / generated k-mers between two scafffolds or species -> getting these from shared_k_mers and generated_k_mers functions
# - Length of each scaffold
# - k of k-mer


import pandas as pd
from pathlib import Path
import logging

# Compute the number of shared or common k_mers
def shared_k_mers(origin: str, level: str, df_k_mers: pd.DataFrame) -> pd.DataFrame:

    # Get the k-mers of the origin scaffold or species
    df_origin = df_k_mers[df_k_mers[level] == origin]
    df_non_origin = df_k_mers[df_k_mers[level] != origin]

    # Get the k-mers shared with the rest of scaffolds or species
    df_shared = df_origin.merge(df_non_origin, on = ['k', 'k_mer'], how='inner')
    df_shared.rename(columns = {
                        'species_y': 'species',
                        'replicon_accession_y': 'replicon_accession'}, inplace = True)

    # Remove the k-mers shared within the same species
    df_shared = df_shared.loc[df_shared['species_x'] != df_shared['species'], ['k', level, 'k_mer']]

    # Get the number of k-mers shared with the rest of scaffolds
    df_common_k_mers = df_shared.groupby(['k', level]).count().reset_index()
    df_common_k_mers = df_common_k_mers[['k', level, 'k_mer']].rename(columns = {'k_mer': 'common_k_mers'})

    return df_common_k_mers


# Compute the number of k-mers generated by the scaffold or species of interest together
# with the scaffold or species of that row
def generated_k_mers(origin: str, level: str, k_mers_counter: pd.DataFrame) -> pd.DataFrame:
    # Let's remove the rows with NaN values
    # But then, we will remove the information from the scaffold of interest
    # Let's keep it in a separate dataframe
    k_mers_counter_origin = k_mers_counter.loc[k_mers_counter[level] == origin, ['k', 'total_k_mers', 'length']]

    # Remove the rows with NaN values
    k_mers_counter_common = k_mers_counter.loc[k_mers_counter['common_k_mers'].notnull()]

    # Merge the two dataframes, creating a new column containing the number of k-mers generated by the original scaffold
    k_mers_counter_common = k_mers_counter_common.merge(k_mers_counter_origin[['k', 'total_k_mers', 'length']], on = ['k'], how = 'left', suffixes = ('', '_origin'))

    # Compute the number of k-mers generated by the two scaffolds
    k_mers_counter_common['generated_k_mers'] = k_mers_counter_common['total_k_mers'] + k_mers_counter_common['total_k_mers_origin'] - k_mers_counter_common['common_k_mers']

    return k_mers_counter_common


# Metric computation
def metric_computation(level: str, k_mers_counter: pd.DataFrame):

    # Compute the probability of finding a common k-mer
    k_mers_counter['probability'] = k_mers_counter['common_k_mers'] / k_mers_counter['generated_k_mers']

    # First, we want to apply the desired formula:
    # (1 - probability) * (1 - (m / (n*k^2)))
    # Where: m, n are the length of the two scaffolds/species with m being the shortest represented in length and length_origin columns
    shortest_length = k_mers_counter[['length', 'length_origin']].min(axis=1)
    longest_length = k_mers_counter[['length', 'length_origin']].max(axis=1)
    # Transform k to int to be able to compute the metric
    k_mers_counter['k'] = k_mers_counter['k'].astype(int)

    k_mers_counter['metric'] = ((1 - k_mers_counter['probability']) * (1 - (shortest_length / (longest_length * pow(k_mers_counter['k'], 2))))).astype(float)

    # Do the product of the metric for each scaffold/species among all the k values
    if level == 'replicon_accession':
        return (k_mers_counter[['species', 'replicon_accession', 'metric']]
                .groupby(['species', 'replicon_accession'], as_index=False)
                .prod()
                .sort_values(by=['species', 'metric'], ascending=[True, False]))
    elif level == 'species':
        return (k_mers_counter[['species', 'metric']]
                .groupby('species', as_index=False)
                .prod()
                .sort_values(by=['species', 'metric'], ascending=[True, False]))
    else:
        raise ValueError('Level must be either replicon_accession or species')
        return None


def k_mers_to_metric(origin: str, level: str, k_mers_counter: pd.DataFrame, df_length: pd.DataFrame, df_k_mers: pd.DataFrame) -> pd.DataFrame:

    # Add the length of the scaffold or species to the dataframe
    k_mers_counter = k_mers_counter.merge(df_length[[level, 'length']], on = level, how = 'left')

    # Now, we need to compute the number of k-mers shared from the origin with the rest of elements
    logging.info('Computing shared k-mers for ' + origin + ' '  + level)
    df_common_k_mers = shared_k_mers(origin, level, df_k_mers)

    k_mers_counter = k_mers_counter.join(df_common_k_mers.set_index(['k', level]), on=['k', level], how='left')

    # Now, we have the total k-mers per scaffols and the numbger of k-mers shared with the rest of scaffolds, i.e., the intersection between the two groups
    # We want to compute the number of k-mers generated by the two scaffolds
    # We can do this by computing the number of k-mers generated by the two scaffolds and subtracting the number of k-mers shared with the rest of scaffolds
    # Done under generated_k_mers function
    logging.info('Computing generated k-mers for ' + origin + ' '  + level)
    k_mers_counter = generated_k_mers(origin, level, k_mers_counter)
    k_mers_counter.to_csv('../Data/Intermediate/k_mers_counter.csv', index=False)

    # Now, we can compute the metric
    logging.info('Computing metric for ' + origin + ' '  + level)

    # Compute the metric
    # The metric is 1 - metric_computation()
    df_metric = metric_computation(level, k_mers_counter)
    
    # Now, return 1 - df_metric to get the metric
    df_metric['metric'] = 1 - df_metric['metric']

    return df_metric